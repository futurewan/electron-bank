# 银企自动核销 Agent — 核心业务场景与技术实现细节文档

> 本文档详细阐述了「银企自动核销 Agent」的核心技术架构、算法实现细节、数据库设计以及关键业务场景的解决思路。适用于项目交接、二次开发参考以及技术汇报选编。

---

## 1. 核心架构与技术栈选型思路

本项目采用 **Electron + React + Python + LLM** 的混合架构，核心目标是打造一个**完全本地化、数据不上云**（除必要的大模型 API 调用外）的智能财务对账工具。

### 1.1 架构分层设计
1. **表现层 (Renderer Process)**:
   - 基于 React 18 + Zustand + Ant Design 6 实现。
   - 完全与业务逻辑解耦，只负责 UI 呈现与用户交互。
   - 所有数据和操作通过 `window.electron` Bridge (Preload 脚本) 传递给主进程。
2. **逻辑引擎层 (Main Process)**:
   - Node.js (Electron Main) 承担后端角色。
   - 包含文件扫描、去重、三级匹配引擎、报告生成等核心业务逻辑。
3. **数据持久层 (Local Storage)**:
   - 采用 `better-sqlite3` 提供高性能的本地关系型数据库。
   - `Drizzle ORM` 提供强类型、防 SQL 注入的数据映射层。
4. **解析外挂层 (Python Sub-process)**:
   - 针对国内复杂的电子发票 PDF 解析需求，调用封装好的 Python 脚本（基于 `pdfplumber`）作为子进程。
5. **智能增强层 (AI API)**:
   - 基于 DeepSeek API (兼容 OpenAI 格式) 提供兜底的语义理解和数据修复。

---

## 2. 三级漏斗匹配引擎：如何解决财务对账痛点？

财务对账最大的痛点不仅在于数据量大，更在于**"微小差异" (手续费扣减) ** 和 **"非标代付" (张三代表公司A付款)**。本系统设计了三层漏斗匹配机制，在保证 100% 准确率的前提下，尽可能提高自动化匹配率。

### 2.1 第一层：规则精准与容差匹配 (`matchingService.ts`)
最坚实、速度最快的地基，解决 80% 以上的标准化对账。

*   **执行方式**：双重循环遍历未匹配的银行流水和发票，使用内存 Set 缓存已匹配 ID 防止重复 (`matchedBankIds`, `matchedInvoiceIds`)。
*   **前置处理**：调用 `normalizeName()` 对企业名称进行高度归一化，剔除括号、空格，保留或剥离特定的公司后缀。
*   **策略 A: 完美匹配 (Perfect Match)**
    *   **条件**：发票金额 `===` 流水金额，**并且** 归一化后的流水户名 `===` 发票的销方或购方名称。
    *   **特殊规则**：如果流水备注明确包含 "货款收入"，则严格校验流水户名必须等于发票购方名称。
*   **策略 B: 手续费容差匹配 (Tolerance Match)**
    *   **场景**：银行转账扣除了个位数或十几元的手续费。
    *   **条件**：发票金额 `>` 流水金额，**并且** `(发票金额 - 流水金额) <= 20`（系统预设容差阈值），**并且** 归一化户名一致。
    *   **标记**：生成 `matchType = 'tolerance'` 的记录记录具体的手续费差异。

### 2.2 第二层：历史影射代付匹配 (`matchingService.ts` Level 3)
解决常见的 "老板个人卡代公司付款" 问题。

*   **数据结构**：系统维护一张 `payer_mappings` (付款人映射) 表，记录了 `(个人名) -> (公司名)` 的多对多关系。在匹配前，将其构建为内存哈希表 `personToCompanies: Map<string, string[]>`。
*   **执行条件**：当前流水户名在映射表中存在。
*   **匹配逻辑**：如果该流水户名关联的某家公司名称，等于某张未匹配发票的销方或购方，**并且**金额符合完美匹配或容差匹配规则，则判定为**代付匹配** (`matchType = 'proxy'`)。

### 2.3 第三层：AI大模型语义匹配兜底 (`aiMatchingService.ts`)
解决首次出现的代付关系、备注过于口语化等无法用 `if/else` 穷尽的边缘场景。这也是本项目的**核心技术壁垒**。

*   **预处理：候选池筛选**：为防止 Token 浪费并控制幻觉，绝不把所有数据塞给 AI。而是为每一条未匹配流水，寻找**候选发票 (Top 5)**：
    *   金额差异比例 `<= 10%`。
    *   日期差异 `<= 30天`。
*   **阶段一：逐条 AI 判决**：
    *   将流水的 (户名、摘要、金额、日期) 与候选发票的 (销方、购方、开票项、备注、金额) 构建为严格的 JSON Context Prompt 向 DeepSeek 发起请求。
    *   要求 AI 以 JSON 响应：是否匹配 (`matchFound`)、是否是代付 (`isProxy`)、是否由于手续费 (`isHandlingFee`)。
    *   **自动知识沉淀**：如果 AI 判断为代付 (`isProxy=true`) 且提供了 `proxyMapping`，系统不仅完成本次核销，还会自动将该代付对静默写入 `payer_mappings` 数据库。下次同样的代付将直接命中第二层本地规则，实现系统"越用越聪明"。
*   **阶段二：全局沙盘分析 (Global Batch Analysis)**：
    *   如果逐条匹配后仍有剩余，将所有剩余脏数据打包成一次会话（提高置信度阈值至 > 0.8），让大模型做最后一次全局关系的"连线"操作。

---

## 3. PDF解析：应对国内极其复杂的发票版式

国内电子发票存在多种版式（标准防伪税控增值税发票、全电发票、纸质扫描打码发票）。传统的正则表达式解析极其脆弱。

系统采用 `invoiceParseService.ts` (TS 调度层) + `invoice_parser.py` (Python 解析底层) + 大模型修复的混合策略。

### 3.1 Python 硬解析底层 (`pdfplumber`)
Python 子进程针对发票 PDF 执行层层深入的降级解析策略：
1.  **元数据提取** (`_extract_metadata`)：部分全电发票的属性直接写在 PDF 的 Metadata XML 节点内，此法速度最快、准确率 100%。
2.  **表格结构提取** (`_extract_buyer_seller_from_table`)：利用 `pdfplumber.extract_tables` 处理包含实体网格线的传统增值税发票。
3.  **文本模式正则匹配** (`_extract_buyer_seller_from_text`)：处理全电发票（无网格线），寻找诸如 `购 名称：张三 销 名称：李四` 这种同行特征。
4.  **稀疏矩阵遍历** (`_extract_sparse_format`)：针对排版完全混乱的 PDF，提取所有纯文本和数字进行打分权重定位。
5.  **校验推算** (`_derive_amounts`)：利用查找到的“小写总计”与“税率”反推价税合计，或利用“大写金额”与“小写金额”互校验。

### 3.2 大模型 "僵尸发票" 修复机制 (AI Phase 1)
这是 OpenSpec 中定义的 `[enhance-ai-matching-core]` 技术实现。

*   **何为僵尸发票？**：上述 Python 硬解析极尽所能后，仍会出现读取为空白、`amount = 0` 或 `sellerName = '未知'` 的失败数据。这些数据在过去只能人工废弃。
*   **AI 拯救流程 (`repairBrokenInvoices`)**：
    1. 在进入三级漏斗匹配**之前**，主动查询这种有缺陷的发票。
    2. 让 Python 读取该 PDF 的**纯字面 Raw Text**（不关心排版，前3000字符）。
    3. 调用大模型，将混乱的一坨无排版文本交由 LLM 进行语义结构化：*“由于格式混乱，正则失效。这堆文本是一张发票的文本，请帮我找出它的买方、卖方和价税合计。以 JSON 回复。”*
    4. 将取回的正确数据 Update 到数据库，标记 `parseSource = 'ai_repair'`。这批原本死掉的发票“起死回生”，重新进入常规核销队列。

---

## 4. 异常检测与大模型诊断 (`exceptionService.ts`)

不仅在匹配成功时输出报表，系统还要为**未平账**的情况出具高维度的异常诊断报告（风控审计视角）。

### 4.1 四大硬性异常监测
1.  **有水无票 (NO_INVOICE)**：查找全部处于 `pending` 状态且金额巨大的单边银行流水。
2.  **有票无水 (NO_BANK_TXN)**：查找全部未消耗的大额发票。
3.  **涉嫌重复支付 (DUPLICATE_PAYMENT)**：
    - 查询流水表：基于复合键 (付款人 + 转入金额 (精确到分))。
    - 判断日期：如果间隔在 7 天之内出现了两笔上述复合键完全相同的数据。
    - **逻辑**：不拦截正常业务，但打上高危 Tag 交由人工处理（可能财务重复汇款）。
4.  **恶意容差/金额悬殊 (AMOUNT_MISMATCH)**：匹配结果虽然被规则判定通过，但金额差异巨大（例如由于误操作匹配了超过 100 元的手续费），标记异常警告。

### 4.2 AI 异常深潜诊断
对于上述捞出的系统死信（Exceptions），调用 AI 进行诊断。
*   向 LLM 提供单条异常的完整上下文 JSON（包前一笔流水记录、当前库中待分配的发票等）。
*   让 LLM 生成中文的“诊断结论” (diagnosis) 与“指导建议” (suggestion)。例如大模型可能会发现：“*该笔有票无水异常，可能是因为该发票金额（10000元）恰好等于前面的两笔单边银行流水（5000+5000）之和，推测为分批打款导致单笔规则无法识别，建议人工合并流水后核销。*”

---

## 5. 本地化与性能优化的架构细节

1.  **重置与幂等性设计**：
    *   每次点击“开始核销”，流程首先进入清理逻辑，利用 `drizzle` 大批量 `delete` 清理当前 `batch_id` 历史产生的 `match_results`、`exceptions` 和 `reports`，重置源数据状态。确保用户即使修改配置文件反复重跑核销，数据库也不会发生脏数据交叉污染。
2.  **源数据进场前严格去重**：
    *   对于银行流水，基于 MD5 / 复合键 (`payerName|amount|dateStr`) 清理被用户误导入的重复 Excel 行（防止造成假性的重复支付异常）。
    *   **跨批次 PDF 发票去重**：对于传入的全新 PDF，系统首先向数据库全表查询相同的 `invoiceNumber`。一旦发现该发票在过往其他月份/批次已经被入库或核销，在前端坚决拦截并高亮“跳过重复导入”，彻底断绝了一张发票在两个月份被复用核销的财务造假或低级错误隐患。
3.  **UI 假死防范机制（Event Loop 释放）**：
    *   Electron 主进程如果被数千次同步的 Node.js `for` 循环完全堵塞，界面将无法收到进度条回调 IPC 进而彻底假死（白屏），用户点击“停止核销”的动作也无法响应。
    *   解决方案：在 Level 1 / Level 2 / Level 3 的 `for` 循环内，硬编码注入 `if (i % 100 === 0) await new Promise(resolve => setTimeout(resolve, 0))` 强制挂起调用栈让出控制权，确保 IPC 通信在海量循环计算中也能保持丝滑流畅的数据通信和状态机随时中止机制。
4.  **自动归档防污染**：
    *   对账完成后，通过 Node.js 原生 `fs API`，自动在硬盘工作区构建类似 `20260222-1` 的归档文件夹架构。
    *   将待处理的零散 Excel 和成百上千张 PDF 移入冷库，将最终生成的 3 份 Excel 三重报表放在顶层。确保用户下个月打开软件直接处理桌面根目录新来的文件即可，无须人工移动老文件，做到了极致的工作流自动化。

---
*编撰：AI 架构师*  
*数据基准：基于 `electron/services/` Core 源码深潜分析*
